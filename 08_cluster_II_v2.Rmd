# Clusteranalyse II: Gemischtskalige Modelle {#cluster2}

## ğŸ“¢ Zielsetzung dieser Einheit {.unnumbered}

In dieser Einheit behandeln und erproben wir die Bildung gemischtskaliger Clustermodelle.

```{r echo=FALSE, purl=FALSE}
# myScriptname <- tools::file_path_sans_ext(tail(strsplit(rstudioapi::getSourceEditorContext()$path, "/")[[1]], 1))
myScriptname <- "08_cluster_II_v2"

knitr::asis_output(paste(
  "<p><strong>tl;dr: </strong>",
  "<a href=\"https://kamihoeferl.at/lehre/vu_sozwiss_2/",
  myScriptname,
  ".R\" type=\"application/octet-stream\">Her mit dem Code!</a></p>",
  sep = ""))
```

---

## (Wie) Funktioniert gemischtskalige Clusterung?

Praktisch stellt sich oftmals der Wunsch, Variablen mit unterschiedlichen Skalenniveaus fÃ¼r eine Clusterung zu nutzen. Zwei prominente Strategien, um solche gemischtskaligen Modelle (aka "mixed models") umzusetzen sind:

-   Die Verwendung eines passenden ProximitÃ¤tsmaÃŸes - beispielsweise der **Gower-Distanz** - in Kombination zu klassischen **hierarchischen bzw. partitionierenden Gruppierungsverfahren**;
-   Die Verwendung des **Log-Likelihood-Distanz** im Rahmen des **Two-Step-Gruppierungsverfahrens**.

Aus didaktischen GrÃ¼nden fokussiert diese Einheit auf die Nutzung der Gower-Distanz zur hierarchischen Clusterung. Interessierte am Thema Two-Step-Clusterung mÃ¶chte ich auf die Beschreibung des [R-Packages "prcr"](https://cran.r-project.org/web/packages/prcr/prcr.pdf) verwiesen.

## Die Gower-Distanz

Im Gegensatz zu euklidischen Distanz kann die Gower-Distanz auch von gemischtskalige Sets von Merkmalen berechnet werden. Dazu werden in der Gower-Distanz die Manhatten-Distanz fÃ¼r metrische mit dem WÃ¼rfelmaÃŸ fÃ¼r nominale und ordinale Merkmale kombiniert:

$$
d_{Gower (i,j)} = 
\frac{\sum_{k=1}^{p}\delta_{ij}^{(k)}d_{ij}^{(k)}}
{\sum_{k=1}^{p}\delta_{ij}^{(k)}} \\
$$

$$
\begin{aligned}
  & i, j ~ ...~ \text{Beobachtungen i und j} \\
  & k ~ ...~ \text{k-tes Merkmal (= Variable)} \\
  & p ~ ...~ \text{Anzahl der Merkmale (= Variablen)} \\
  & \delta_{ij}^{k} ~ ...~ \text{'Spannweite' des binÃ¤ren Mermals k (= 1)} \\
  & d_{ij} ~ ...~ \text{Ãœbereinstimmung binÃ¤re MerkmalsausprÃ¼gung Beobachtung i und j} \\
\end{aligned}$$

Die Ãœbereinstimmung $d_{ij}$ wird dabei wie folgt ermittelt:

$$
d_{ij}^{(k)} = \begin{cases}
    1 & \text{wenn } x_{ik} \neq x_{jk} \\
    0 & \text{wenn } x_{ik} = x_{jk}
  \end{cases}
$$

Bei metrischen Merkmalen wird die Gower-Distanz anhand folgender Formel ermittelt:

$$
d_{Gower (i,j)} =
\sum_{k=1}^{p} \frac{|x_{ik} - x_{jk} |} {R_{k}}
$$

Wobei $R_{k}$ wie folgt ermittelt wird:

$$
R_{k} = max_{ik} - min_{ik} = \text{Spannweite der Variable k}
$$

Die so ermittelte Gower-Distanz weist ein Wertspektrum von 0 (= identisch) bis 1 (= deutlich unterschieden) auf.

**Sehr schÃ¶n:** Time for some Action

## Ein Beispiel: ÃœberprÃ¼fung der "Hillbilly-These" zur COVID-19-Schutzimpfung

["Hillbilly"](https://en.wikipedia.org/wiki/Hillbilly) ist ursprÃ¼nglich eine stereotype Bezeichnung fÃ¼r Bewohner der lÃ¤ndlich-geprÃ¤gten Teile der Vereinigten Staaten von Amerika. Mit zunehmender Dauer der Pandemie mehren sich die Befunde, u.a. in den lÃ¤ndlichen Regionen der USA eine **"Vaccine Hesitancy"** festgestellt werden kann:

* Rural Americaâ€™s False Sense of Security: https://www.theatlantic.com/politics/archive/2021/11/pandemic-covid-urban-rural-divide/620730/
* Vaccine Hesitancy in Rural America: https://www.kff.org/coronavirus-covid-19/poll-finding/vaccine-hesitancy-in-rural-america/
* COVID-19 Vaccination Hesitancy in the United States:  https://link.springer.com/article/10.1007/s10900-020-00958-x

Neben dem schlechteren Zugang zu medizinischer Versorgung belegen diese ersten Befunde die Bedeutsamkeit weltanschaulicher Ãœberzeugungen fÃ¼r die Entscheidung zur COVID-19-Schutzimpfung.

Ausgehend von diesen befunden, wollen wir uns in Ã–sterreich auf die Suche nach einer lÃ¤ndlich geprÃ¤gten, weltanschaulich beeinflussten Skepsis gegenÃ¼ber der COVID-19-Schutzimpfung machen. Oder etwas flapsiger formuliert: **Gibt es so etwas wie Ã¶sterreichische Impf-Hillbillies?**

Und wenn ja: 

* Wie verbreitet sind sie?
* Wo sind sie zu finden?

**Methodologisch wollen wir dabei folgendermaÃŸen vorgehen:**

1. Wir formulieren zunÃ¤chst die "Hillbilly-These": Je lÃ¤ndlicher und weltanschaulich impfskpetisch eingestellt die BewohnerInnen in einer Gemeinde sind, desto geringer fÃ¤llt die COVID-19-Impfquote in diesen Gemeinden aus.
2. Diese These werden wir fÃ¼r den Zeitpunkt Oktober 2021 mittels Clusteranalyse evaluieren:  
Dabei werden wir die Ã¶sterreichischen Gemeinden anhand folgender drei Eigenschaften klassifizieren:

  * **Kommunale COVID-19-Impfquote:**  
  bereitgestellt durch das Bundesministerium fÃ¼r Soziales, Gesundheit, Pflege und Konsumentenschutz unter: https://www.data.gv.at/katalog/dataset/covid-19-schutzimpfungen-impfungen-in-gemeinden/resource/89ad8077-0318-4dfb-953f-0824754b5adc
  * **StÃ¤dtisch-lÃ¤ndlicher Charakter der Gemeinde:**  
  umgesetzt anhand der [Urban-Rural-Typologie der Statistik Austria](https://www.statistik.at/web_de/klassifikationen/regionale_gliederungen/stadt_land/index.html), bereitgestellt unter: https://www.statistik.at/wcm/idc/idcplg?IdcService=GET_NATIVE_FILE&RevisionSelectionMethod=LatestReleased&dDocName=108339
  * **Weltanschauliche Impfskepsis der BeweohnerInnen:**  
  nÃ¤herungsweise abgebildet Ã¼ber den kommunalen Stimmanteil der FPÃ– bei der Nationalratswahl 2019, bereitgestellt durch das Bundesministerium fÃ¼r Inneres unter: https://www.data.gv.at/katalog/dataset/ergebnisse-der-nationalratswahl-2019-aviso/resource/3865d49b-9d3c-480a-8d0e-959bebddc81a
  
3. Sollten wir diese These positiv evaluieren, wollen wir abschlieÃŸend die rÃ¤umliche Verbreitung dieses PhÃ¤nomens anhand einer thematischen Karte klÃ¤ren. 

Die oben angefÃ¼hrten Daten kÃ¶nnen gesammelt [**ğŸ”½ als Excel-Datei hier heruntergeladen werden ğŸ”½**](data/corona_gem_cluster_v2.xlsx).

> **ğŸ‘‰ Anmerkung**:  
Wir gehen in dieser Einheit von folgender Verzeichnisstruktur aus:

    **Projektfolder**
    | skript_1.R
    | ...
    | skript_n.R    
    +-- data
    |     | datensatz_1.xyz
    |     | ...
    |     | datensatz_n.xyz
    +-- output

## Einige VorÃ¼berlegungen {#vorueberlegungen-cluster-2}

Bevor wir die eigentliche Cluster-Analyse durchfÃ¼hren, mÃ¼ssen wir uns jedoch die folgenden Fragen stellen:

1.  **Kann eine Gleichgewichtung der der Merkmale (= Variablen) sichergestellt werden?**\
    Da vorab keine Informationen zur Bedeutung einzelner Variablen fÃ¼r die Gruppierungen der MerkmalstrÃ¤ger vorliegen, wird eine Gleichgewichtung der Variablen angenommen. Korrelierte Variablen wÃ¼rden dieser Gleichgewichtung zuwiderlaufen. Sollten stark korrelierte Variablen (Daumenregel: > 0,8) vorliegen:

    -   sollten diese von der Clusterung ausgeschlossen werden;
    -   Kann eine explorative Faktorenanalyse der Clusterung vorgeschalten werden.

2.  **Weisen die gewÃ¤hlten Variablen "genÃ¼gend" Varianz auf?**\
    Konstante Variablen wÃ¤ren in der Clusterung nicht trennungswirksam und sollten daher ausgeschlossen werden.

3.  **Sind die Messskalen meiner Variablen vergleichbar?**\
    Sollten unterschiedliche Messskalen vorliegen, empfiehlt sich eine z-Transformierung der Variablen. Dadurch kann eine indirekte Gewichtung der Variablen vermieden werden (vgl. Punkt 2).

4.  **Wie werden AusreiÃŸer in der Analyse identifiziert und behandelt?**\
    Da AusreiÃŸer meist zu heterogenen Cluster-LÃ¶sungen fÃ¼hren, sollten "extreme" AusreiÃŸer von der weiteren Analyse ausgeschlossen werden.

Diese Fragen wollen wir in weiterer Folge kurz behandeln.

ğŸ§ Und was sagt der Captain dazu?

![](images/make_it_so.gif){.videoframe width="210"}

## Die Datenaufbereitung

```{r}
library(readxl)     # Excel-Dateien lesen
library(tidyverse)  # https://www.tidyverse.org/packages/

daten <- read_excel("data/corona_gem_cluster_v2.xlsx", sheet = "ex")

# qual. Variablen setzen
daten <- daten %>%
  mutate(ur_metatypus = factor(ur_metatypus, labels = c("Urbane RÃ¤ume",
                                                "Regionale Zentren",
                                                "LÃ¤ndliches Umland",
                                                "LÃ¤ndlicher Raum")),
         ur_typus = factor(ur_typus, labels = c("Urbane GroÃŸzentren",
                                                "Urbane Mittelzentren",
                                                "Urbane Kleinzentren",
                                                "Regionale Zentren, zentral",
                                                "Regionale Zentren, intermediÃ¤r",
                                                "LÃ¤ndlicher Raum im Umland von Zentren, zentral",
                                                "LÃ¤ndlicher Raum im Umland von Zentren, intermediÃ¤r",
                                                "LÃ¤ndlicher Raum im Umland von Zentren, peripher",
                                                "LÃ¤ndlicher Raum, zentral",
                                                "LÃ¤ndlicher Raum, intermediÃ¤r",
                                                "LÃ¤ndlicher Raum, peripher")),
         degurba_21 = factor(degurba_21))

```

Wie gehabt werfen wir einen Blick auf mÃ¶gliche LÃ¼cken im Datensatz:

```{r}
colSums(is.na(daten)) %>%
  knitr::kable()
```

GlÃ¼cklicherweise ist dies nicht der Fall.

## Ein Blick auf die gewÃ¤hlten Clustervariablen

Wir definieren zunÃ¤chst die zur Clusterung genutzten Variablen ...

```{r}
myQuantVars = c("immun_100k", "anteil_fpoe")
myQualVars = c("ur_metatypus")
myVars = c(myQuantVars, myQualVars)
```

... um uns danach einen Einblick in deren Wertverteilungen zu verschaffen; zunÃ¤chst numerisch ...

```{r}
daten %>%
  select(all_of(myVars)) %>%
  summary()
```

... und natÃ¼rlich auch graphisch:

```{r}
daten %>%
  select(all_of(myQuantVars)) %>%
  pivot_longer(cols = everything(), names_to = "Variable", values_to = "Messwert") %>%
  ggplot(., aes(x = "", y = Messwert)) +
  geom_boxplot() +
  labs(x = "Variablen", y = "Messwerte\n") +
  facet_wrap(~ Variable, scales = "free_y")

daten %>%
  group_by(ur_metatypus) %>%
  summarise(n = n(), .groups = "drop") %>%
  ggplot(. , aes(x = "", y = n, fill = ur_metatypus)) +
  geom_bar(stat = "identity", position = 'fill') +
  labs(x = "ur_typus", y = "Anteile [%]")
```

Wir sehen, dass vor allem die qualitative Variable ur_metatypus nur bedingt streut. Dieser "Quasi-Konstanz" (mehr als 50% der Gemeinden liegen im "LÃ¤ndlichen Raum") werden wir im weiteren Verlauf der Analyse besondere Aufmerksamkeit widmen.

Da die beiden metrischen Variablen auf unterschiedlichen Messskalen gemessen werden, nehmen mir eine z-Transformation vor. Dadurch kÃ¶nnen wir eine (unabsichtliche) Gewichtung dieser beiden Variablen verhindern:

```{r}
daten_trans <- daten %>%
  select(gem_id, gem_txt, all_of(myVars)) %>%
  mutate(across(all_of(myQuantVars), scale)) %>%
  mutate_if(is.matrix, as.numeric)  # scale liefert eine Matrix und keinen numeric > wieder zurÃ¼ckstellen
```

Zuletzt wollen wir noch einen Blick auf die Korrelationen zwischen unseren metrischen Clustervariablen werfen:

```{r}
library(GGally)
ggpairs(daten, myQuantVars)
```

GemÃ¤ÃŸ unser Daumenregel "Keine Korrelation stÃ¤rker als +/- 0,8" sehen wir, dass beide Variablen in die Clusterung eingehen kÃ¶nnen.

## Ermittlung der Ã„hnlichkeiten

Bevor wir die Ã„hnlichkeiten zwischen den Gemeinden ermittel kÃ¶nnen, mÃ¼ssen wir noch eine kleine Ã„nderung an unserem Datensatz vornehmen: Um bei den weiterfÃ¼hrenden Berechnung den Gemeindecode automatisch als Label nutzen zu kÃ¶nnen, muss dieser als Zeilenname ("Rowname") hinterlegt werden:

```{r}
daten_trans_fit0 <- daten_trans %>%
  mutate(gem_id_rows = gem_id) %>%
  tibble::column_to_rownames("gem_id_rows")
```

Aufgrund der unterschiedlichen Skalen unserer Clustervariablen nutzen wir zur Abbildung der (Un-)Ã„hnlichkeit unserer Gemeinden die eingangs beschriebene **Gower-Distanz**:

```{r}
library(cluster)
gower_dist_fit0 <- daisy(daten_trans_fit0[myVars], metric = "gower")
summary(gower_dist_fit0)
```

Die Summary zeigt uns, dass die Skalen unserer Clustervariablen korrekt erkannt wurden: Types = I, I, N steht fÃ¼r zwei intervall- und eine nominal skalierte Variable. Ein Blick auf die Minima und Maxima zeigt uns, dass sehr Ã¤hnliche (Minimum nahe bei 0) und unÃ¤hnliche (Maximum nahe bei 1) in unserem Datensatz enthalten sind.

Ausgehend von diesen Ã„hnlichkeiten kÃ¶nnen wir uns als nÃ¤chstes auf die Suche nach mÃ¶glichen AusreiÃŸern machen.


## Identifikation von AusreiÃŸern

Hierzu greifen wir wieder auf eine einfache Single-Linkage Clusterung zurÃ¼ck:

```{r}
fit0 <- hclust(gower_dist_fit0, method = "single")
plot(fit0, main = "Single Linkage Clusterung", cex = 0.65)
```

Aufgrund der hohen Anzahl an MerkmalstrÃ¤gern gestaltet sich hier die rein visuelle Interpretation des Dendrogramms als nicht sehr ergiebig ğŸ™„.

Wir kÃ¶nnen uns aber den Fusionierungsverlauf numerisch Ã¼ber eine Funktion als sgn. "Agglomeration Schedule" darstellen lassen:

```{r}
get.agglo <- function(clustermodell){
  data.frame(row.names=paste0("Cluster",seq_along(clustermodell$height)),
             height=clustermodell$height,
             components=ifelse(clustermodell$merge<0, clustermodell$labels[abs(clustermodell$merge)],
                               paste0("Cluster",clustermodell$merge)),
             stringsAsFactors=FALSE)
}

tail(get.agglo(fit0), 10)
```

Wir sehen, dass die Gemeinde 20503 als letzte verbleibende Gemeinde einem Cluster zugeordnet wurde. Ein Blick auf den Verlauf der Variable "height" - also dem Ansteigen HeterogenitÃ¤t der gefundenen ClusterlÃ¶sungen - zeigt uns keine drastischen VerÃ¤nderungen. Wir kÃ¶nnen damit keine AusreiÃŸer ausmachen und mÃ¼ssen daher auch keine Gemeinden vorab aus dem Datensatz entfernen.

Und damit kommen wir ...

## Clusterung der Gemeinden

Um Ã¤hnlich besetzte Cluster zu erhalten, greifen wir dabei auf den **Ward-Algorithmus** zur Fusionierung zurÃ¼ck:

```{r}
fit1 <- hclust(gower_dist_fit0, method="ward.D2")
plot(fit1, main = "Ward-Clusterung", cex = 0.5)
```

Ein Blick auf das Dendrogramm deutet uns zwei groÃŸe Gruppen mit mehreren Untergruppen an. Um die Anzahl der zu wÃ¤hlenden Cluster zu bestimmen erstellen wir das aus Kapitel \@ref(cluster1) bekannte **Elbow-Diagramm**:

```{r}
# HeterogenitÃ¤t der letzten 10 Schritte holen
height <- sort(fit1$height)
Schritt <- c(10:1)
height <- height[(length(height)-9):length(height)]
screeplot_data_1 <- data.frame(Schritt, height)
# plotten
ggplot(screeplot_data_1, aes(x=Schritt, y=height)) +
  geom_line(size=1) +
  scale_x_continuous(breaks=Schritt) +
  labs(title = "Elbow-Diagramm", x = "Anzhal Cluster") +
  geom_vline(xintercept=6, color = "red")

```

Um einen mÃ¶glichst detailliert bei der Evaluation der "Hillbilly-These" vorgehen zu kÃ¶nnen, entscheiden wir uns fÃ¼r 6 Cluster.

```{r}
nCluster <- 6
# Dendorgramm erstellen
plot(fit1, cex = 0.75, main = "Ward Clusterung")
rect.hclust(fit1, k = nCluster, border="red")
```

Diese LÃ¶sung liefert uns ...

```{r}
table(cutree(fit1, k = nCluster))
```

... drei stark, zwei mittel und einen schwach besetzten Cluster.

Diese Cluster speichern wir zunÃ¤chst in den (nicht-)transformierten Datenframes ab:

```{r}
# zunÃ¤chst in den zur Berechnung genutzten Datenframe
daten_trans_fit0$fit1_cl6 <- as_factor(cutree(fit1, k = nCluster))
# dann per join (sicherer bei AusreiÃŸern) im transformierten Ausgangsdatensatz
daten_trans <- daten_trans_fit0 %>%
  select(gem_id, fit1_cl6) %>%
  left_join(daten_trans, ., by = "gem_id")
# ... und noch auf die nicht-transformierten Daten
daten <- daten_trans %>%
  select(gem_id, fit1_cl6) %>%
  left_join(daten, ., by = "gem_id")
```

## Beurteilung der TrennschÃ¤rfe der gewÃ¤hlten Clusteranzahl

Bevor wir zur Charakterisierung der Cluster Ã¼bergehen, wollen wir zunÃ¤chst noch ein Bild von der GÃ¼te - also der TrennschÃ¤rfe - der gewÃ¤hlten Clusteranzahl kommen. In Kapitel \@ref(cluster1) konnten wir dazu fÃ¼r rein metrische Variablen auf eine Hauptkomponentenanalyse zurÃ¼ckgreifen. Diese Vorgehensweise kÃ¶nnen wir hier nicht erneut anwenden, da unsere Clustervariablen ja zu Teilen auch nominal skaliert sind.

GlÃ¼cklicherweise kÃ¶nnen solche gemischtskaliges Datenset - genauer gesagt: die Distanzen zwischen den MerkmalstrÃ¤gern eines solchen Sets - mittels des [**t-distributed stochastic neighbor embedding** Verfahrens](https://en.wikipedia.org/wiki/T-distributed_stochastic_neighbor_embedding) in einem zweidimensionalen Raum abgebildet werden. Dieses Verfahren versucht mehrdimesionale Objekte (in unserem Fall: 3) so zweidimensional abzubilden, dass Ã¤hnliche Objekte nahe und unÃ¤hnliche weit voneinander entfernt zu liegen kommen. 

> **ğŸ‘‰ Tipp:**  
Da es sich dabei um ein stochastisches Verfahren handelt, empfiehlt es sich in R mittels set.seed einen Ausgangspunkt fÃ¼r die Ermittlung von Zufallszahlen zu setzen. Hierdurch wird - trotz stochastischer Verfahren - die **Reproduzierbarkeit** der Ergebnisse sichergestellt.

Ãœber das Package **Rtsne** bietet uns eine gelungene Implementierung des t-distributed stochastic neighbor embeddings:

```{r message=FALSE, warning=FALSE}
library(Rtsne)
set.seed(1976)

tsne_obj <- Rtsne(gower_dist_fit0, is_distance = TRUE)

tsne_data <- tsne_obj$Y %>%
  data.frame() %>%
  setNames(c("X", "Y")) %>%
  mutate(cluster = daten_trans_fit0$fit1_cl6,
         name = daten_trans_fit0$gem_id)

ggplot(tsne_data, aes(x = X, y = Y)) +
  geom_point(aes(color = cluster))
```

Wir sehen dass 3 der 6 Cluster (1, 3 & 5) sich deutlich von den anderen Clustern unterscheiden. Die Cluster 2, 4 & 6 sind in sich groÃŸteils homogen, lassen sich aber nicht so klar von einander unterscheiden wie die Cluster 1, 3 & 5. Speziell in Hinblick auf die geringe Streuung der Variable ur_metatypus kann diese TrennschÃ¤rfe als noch akzeptabel bezeichnet werden.


## Charakterisierung der Cluster

Werfen wir nun einen ersten numerischen Blick auf unsere Cluster:

```{r}
daten %>%
  group_by(fit1_cl6) %>%
  summarise(across(all_of(myQuantVars), median), .groups = "keep")
```

Ein schneller Blick auf die Mediane zeigt uns, dass beim Anteil der FPÃ–-WÃ¤hlerInnen nur Cluster 4 sich klar abheben kann: In diesem Cluster sammeln sich Gemeinden mit einem klar Ã¼berdurchschnittlichen FPÃ–-Stimmenanteil. Gleichzeitig weist dieser Cluster auch eine geringe Immunisierungsrate auf.

Das ganze noch graphisch - zunÃ¤chst mit den transformierten Daten:

```{r}
daten_trans %>%
  group_by(fit1_cl6) %>%
  summarise(across(all_of(myQuantVars), mean), .groups="keep") %>%
  pivot_longer(all_of(myQuantVars), names_to = "variable", values_to ="wert") %>%
  ggplot(., aes(x=variable, y=wert, fill=variable)) +
  geom_bar(stat = "identity") +
  theme(axis.text.x = element_text(angle = 90)) +
  facet_wrap(~ fit1_cl6)
```

In Hinblick auf die zu evaluierende "Hillbilly-These" erscheint vor allem Cluster 4 interessant: Dieser weist eine Ã¼berdurchschnittliche FPÃ–-AffinitÃ¤t und eine unterdurchschnittliche Immunisierungsquote auf. Dieses Muster wÃ¼rde fÃ¼r die These sprechen. Gleichzeitig weist jedoch Cluster 6 eine leicht unterdurchschnittliche FPÃ–-AffinitÃ¤t und die geringste Immunisierungsquote auf, was dieser These widersprechen wÃ¼rde.
neben den transformierten Daten empfiehlt es sich aber auch immer einen Blick auf die nicht-transformierten Werte zu legen:

```{r}
ggplot(daten, aes(x = fit1_cl6, y = anteil_fpoe, fill = fit1_cl6)) +
  geom_boxplot(outlier.shape = NA) +
  labs(title = "anteil_fpoe", x = "Cluster") +
  geom_jitter(width=0.2,alpha=0.15, color="black") +
  theme(legend.position = "none")
```

Dabei sehen wir, dass vor allem beim FPÃ–-Stimmenanteil sich nur Cluster 4 klar von den restlichen Clustern abhebt.

```{r}
ggplot(daten, aes(x = fit1_cl6, y = immun_100k, fill = fit1_cl6)) +
  geom_boxplot(outlier.shape = NA) +
  labs(title = "immun_100k", x = "Cluster") +
  geom_jitter(width=0.2,alpha=0.15, color="black") +
  theme(legend.position = "none")
```

ErgÃ¤nzt man dies um die Immunisierungsquote, zeigt sich, dass lediglich Cluster 4 der "Hillbilly-These" entspricht: Eine hohe FPÃ–-AffinitÃ¤t trifft dort auf eine der geringsten Immunisierungsquoten.

Bleibe aber noch die Frage zu klÃ¤ren, wie viel "Hill" - also "LÃ¤ndlichkeit" - in cluster 4 anzutreffen ist:

Dazu blicken wir auf die Verteilung der Raumtypen der Rural-Urban-Typologie in den Clustern ...

```{r}
table(daten$fit1_cl6, daten$ur_metatypus)
```

Wir sehen, dass der Raumkategorie "LÃ¤ndlicher Raum" auf drei Cluster aufgeteilt wurde. Die Cluster 1, 3 & 5 decken damit sortenrein die restlichen 3 Rural-Urban-Typen ab. Die bei der Beurteilung der Cluster-TrennschÃ¤rfe festgestellte Ã„hnlichkeit der Cluster 2, 4 & 6 scheint sich damit aus der ZugehÃ¶rigkeit zum "LÃ¤ndlichen Raum" zu erklÃ¤ren.

LÃ¶sen wir die Rural-Urban-Typologie mithilfe der Variable "ur_typus" noch etwas feiner auf ...

```{r}
ggplot(daten, aes(x = fit1_cl6, fill = ur_typus)) +
  geom_bar(position = "fill")
```

... sehen wir, dass doch ziemlich viel "Hill" in unserem Cluster 4 anzutreffen ist: Dieser besteht Ã¼berwiegend aus zentral gelegenen lÃ¤ndlichen RÃ¤umen. Diese ausgewiesene "LÃ¤ndlichkeit" erweist sich als durchaus passfÃ¤hig zur "Hillbilly-These". In Summe scheint unsere "Hillbilly-These" zu einem unserer 6 Cluster zu passen. Gleichzeitig sehen wir aber auch, dass auf die Mehrzahl der (auch lÃ¤ndlichen) Gemeinden diese These sich als nicht erklÃ¤rungskrÃ¤ftig erweist.

In Summe zeigt sich hier klar der stark gruppenbildende Effekt der qualitativen Variable ur_metatyp. Die Cluster 1, 3 & 5 stellen dadurch sortenreine Abbilder der Metatypen dieser Variable dar. Durch die gewÃ¤hlte Anzahl der Cluster wurde letztlich der "LÃ¤ndliche Raum" auf die verbleibenden Cluster 2, 4 & 6 aufgeteilt.

Werfen wir abschlieÃŸend noch einen Blick auf die rÃ¤umliche Verteilung dieser Cluster.


## Die rÃ¤umliche Verteilung der Cluster

Um unsere zumindest zu Teilen nicht widerlegte "Hillbilly-These" zu verfeinern, wollen wir noch nachsehen, ob wir insbesondere bei Cluster 4 rÃ¤umliche Muster erkennen kÃ¶nnen. Dazu 

* benÃ¶tigen wir zunÃ¤chst die Geometriedaten der Ã¶sterreichischen Gemeinden zum Stand 2021;
* diese Daten mÃ¼ssen wir aufarbeiten;
* mit den Attributdaten (= Clusterzuordnung) verschneiden;
* und letztlich als Choroplethenkarte darstellen.

### Die Datenbeschaffung & -aufbereitung

Die Geometriedaten der Ã¶sterreichischen Gemeinden zum Stand 2021 beziehen wir von der Statistik Austria:

ğŸ”½ https://www.data.gv.at/katalog/dataset/stat_gliederung-osterreichs-in-gemeinden14f53/resource/0338035f-8326-46da-bc01-e4682d2409d3 ğŸ”½

Den Inhalt dieses **ZIP-Archivs extrahieren** wir in unserem "data" Ordner in den **Unterordner "gem"**.

> **ğŸ‘‰ Anmerkung**: Wir gehen in weiterer Folge von folgender Verzeichnisstruktur aus:

    **Projektfolder**
    | skript_1.R
    | ...
    | skript_n.R    
    +-- data
    |     gem
    |       | geodatensatz_1.xyz
    |       | ...
    |       | geodatensatz_n.xyz
    |     | datensatz_1.xyz
    |     | ...
    |     | datensatz_n.xyz
    +-- output

In einem ersten Schritt laden wir nun unsere Geometriedaten und wandeln die (warum auch immer ğŸ¤”) als Text ablegte Gemeindekennzahl in eine Zahl um:

```{r}
gem <- read_sf("data/gem/STATISTIK_AUSTRIA_GEM_20210101.shp")
gem$id <- as.integer(gem$id)
```

Aus den Erfahrungen der Einheit \@ref(reg1) Ã¼berprÃ¼fen wir, ob die Wiener Gemeindebezirke in diesem Datensatz enthalten sind:

```{r}
tail(gem, 30)
```

Jep, da sind sie ğŸ˜’. Wir mÃ¼ssen also zunÃ¤chst die Geometrien dieser Bezirke zur Gemeinde Wien (Gemeindekennziffer: 90001) vereinigen. Oder wie die GeoinformatikerInnen zu sagen pflegen: Wir mÃ¼ssen diese Polygone mittels [Union](https://desktop.arcgis.com/de/arcmap/10.3/tools/analysis-toolbox/union.htm) vereinen. DafÃ¼r setzen wir zunÃ¤chst die Gemeindekennziffer aller Wiener Bezirke auf "90001":

```{r}
gem_clean <- gem %>%
  mutate(id = ifelse(id > 90000, 90001, id))
```

Nun lassen wir Ã¼ber die Gemeindekennziffer den **Union-Befehl** aus dem sf-Package laufen ...

```{r}
gem_clean <- gem_clean %>%
  group_by(id) %>%
  summarise(geometry = st_union(geometry))
```

Um zukÃ¼nftige Erstellung dieser Karte abzukÃ¼rzen speichern wir diese bereinigte Fassung in einer SHP-Datei ...

```{r eval=FALSE}
st_write(gem_clean, "data/gem/gem_clean.shp")
```


... und werfen einen Blick auf das Ergebnis:

```{r fig.width=9, fig.height=4.75}
tmap::qtm(gem_clean)
```

### Die Attributdaten joinen

Ãœber einen Join kÃ¶nnen wir nun die ClusterzugehÃ¶rigkeit an die Gemeindegeometrien anhÃ¤ngen:

```{r}
gem_clean_join <- left_join(gem_clean, daten,
                            by = c("id" = "gem_id"))
```

> **ğŸ¤” Warum nochmals per Join?**  
Sollte in der Zwischenzeit die betroffenen Dataframes unterschiedlich sortiert worden sein, wÃ¼rde ein einfaches Ãœbertragen der CluasterzugehÃ¶rigkeit zu falschen Zuordnungen fÃ¼hren. Der bei einem Join durchgefÃ¼hrte Abgleich Ã¼ber die Gemeindekennzahl verhindert eine solche Fehlzuordnung.

### Die rÃ¤umliche Verteilung der Cluster darstellen

Mittels des tmap-Packages kÃ¶nnen wir nun die rÃ¤umliche Verteilung der Cluster darstellen:

```{r fig.width=9, fig.height=4.75}
map_Cl6 <- tm_shape(gem_clean_join) +
  tm_polygons(col = "fit1_cl6",
              title = "6-er Cluster-\nLÃ¶sung",
              palette = "Set3",
              # palette = wes_palette("Zissou1", 5),
              legend.hist = TRUE) +
  # tm_text("id", size = 0.45, alpha = 0.5, remove.overlap = TRUE) +
  tm_scale_bar(position = c("left", "bottom")) +
  tm_legend(outside = TRUE,
            legend.outside.size = 0.15,
            hist.width = 1,
            outer.margins = 0)
map_Cl6
```

Und letztlich auch als unkomprimiertes Rasterbild abspeichern:

```{r message=FALSE, warning=FALSE}
tmap_save(map_Cl6, filename = "output/map_Cl6.png",
          units = "px", dpi = 300,
          width = 2000)
```

------------------------------------------------------------------------

ğŸ† **Nun wissen wir, dass ...**

- ... wir Clusteranalyse auch zur **Evaluation** von (mehr oder minder sinnvollen ğŸ˜‰) **Thesen** nutzen kÃ¶nnen;
- ... wir mittels der **Gower-Distanz** auch gemischtskalige Modelle umsetzen kÃ¶nnen;
- ... die ClusterlÃ¶sungen solcher Modelle oftmals stark durch die verwendeten qualitativen Variablen getrieben sein kÃ¶nnen;
- ... auch die **rÃ¤umliche Verteilung** von Clustern manchmal aufschlussreich sein kann;
- ... wir in R auch **einfache Bereinigungen von Geometrien** vornehmen kÃ¶nnen;
- ... die "Hillbilly-These" in Ã–sterreich eine **beschrÃ¤nkte rÃ¤umliche Reichweite** hat und nicht einheitlich auf "lÃ¤ndliche" Gemeinden angewandt werden kann.

![](images/hillbilly-dance.gif){.videoframe width="210"}
